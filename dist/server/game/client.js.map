{"version":3,"sources":["../../../src/server/game/client.js"],"names":[],"mappings":"m+BAKA,IAAM,cAAgB,GAAhB,KAEA;;;;KAMJ,SANI,MAMJ,CAAY,MAAZ,CAAoB,MAApB,CAA4B,sBANxB,QAMwB,IAC1B,CAAK,OAAL,CAAe,MAAf,CAD0B,IAE1B,CAAK,OAAL,CAAe,MAAf,CAF0B,IAG1B,CAAK,QAAL,CAAgB,IAAhB,CAH0B,IAI1B,CAAK,GAAL,CAAW,kBAAQ,QAAR,EAAX,CAJ0B,IAK1B,CAAK,QAAL,CAAgB,IAAhB,CAL0B,IAM1B,CAAK,SAAL,CAAiB,IAAjB,CAN0B,IAQ1B,CAAK,OAAL,CAAa,EAAb,CAAgB,SAAhB,CAA2B,KAAK,aAAL,CAAmB,IAAnB,CAAwB,IAAxB,CAA3B,EAR0B,cAU1B,CAAO,IAAP,+BAA0C,KAAK,GAAL,IAA1C,EAV0B;;;kBANxB,sDAuBQ,QAAS,gBACnB,IAAI,YAAc,uBAAY,CAAE,KAAM,QAAN,CAAd,CAAd,CADe,OAGnB,CAAQ,SAAR,CAAkB,WAAlB,EAHmB,IAKnB,CAAK,QAAL,CAAgB,KAAK,OAAL,CAAa,IAAb,CAAkB,QAAQ,OAAR,CAAlC,CALmB,IAMnB,CAAK,QAAL,CAAc,EAAd,CAAiB,YAAjB,CAA+B,KAAK,gBAAL,CAAsB,IAAtB,CAA2B,IAA3B,CAA/B,EANmB,IAOnB,CAAK,QAAL,CAAc,EAAd,CAAiB,QAAjB,CAA2B,KAAK,YAAL,CAAkB,IAAlB,CAAuB,IAAvB,CAA3B,EAPmB,UASnB,CAAW,UAAM,CACf,YAAc,iBAAK,QAAQ,SAAR,CAAkB,QAAlB,CAA4B,uBAAS,MAAM,EAAN,GAAa,YAAY,EAAZ,CAAtB,CAA/C,CADe,KAEf,CAAK,QAAL,CAAc,IAAd,CAAmB,OAAnB,CAA4B,MAAK,GAAL,CAAU,QAAQ,QAAR,CAAkB,QAAQ,SAAR,CAAmB,WAA3E,EAFe,KAIf,CAAK,QAAL,CAAgB,OAAhB,CAJe,KAKf,CAAK,SAAL,CAAiB,YAAY,EAAZ,CALF,cAOf,CAAO,IAAP,4BAAuC,MAAK,GAAL,kBAAyB,QAAQ,EAAR,IAAhE,EAPe,CAQd,aARH,EATmB;;wDAuBN,CACb,GAAI,CAAC,KAAK,QAAL,CAAe,CAClB,OADkB,IAIpB,CAAK,QAAL,CAAc,KAAd,GALa,cAOb,CAAO,IAAP,6BAAwC,KAAK,GAAL,kBAAyB,KAAK,QAAL,CAAc,EAAd,IAAjE,EAPa,IASb,CAAK,QAAL,CAAc,YAAd,CAA2B,KAAK,SAAL,CAA3B,CATa,IAUb,CAAK,QAAL,CAAgB,IAAhB,CAVa;;;yDAiBD,UAAW,CACvB,KAAK,OAAL,CAAa,IAAb,CAAkB,SAAlB,CAA6B,SAA7B,EADuB;;;uDAQZ,OAAQ,CACnB,GAAI,KAAK,QAAL,CAAe;;AAGjB,KAAK,QAAL,CAAc,kBAAd,CAAiC,MAAjC,EAHiB;;gEAUF,CACjB,GAAI,KAAK,QAAL,CAAe,CACjB,KAAK,YAAL,GADiB,IAInB,CAAK,OAAL,CAAa,YAAb,CAA0B,KAAK,GAAL,CAA1B,CALiB,cAOjB,CAAO,IAAP,oCAA+C,KAAK,GAAL,IAA/C,EAPiB;;;mCAcV,CACP,OAAO,KAAK,GAAL,CADA,WAhGL,0BAqGS","file":"client.js","sourcesContent":["import shortid from 'shortid';\nimport { find } from 'lodash';\nimport { logger } from '../helpers/vendor';\nimport { createProps } from '../factories/props';\n\nconst CONNECT_DELAY = 750;\n\nclass Client {\n  /**\n   * Creates a new game client.\n   * @param {Server} server\n   * @param socket\n   */\n  constructor(server, socket) {\n    this._server = server;\n    this._socket = socket;\n    this._channel = null;\n    this._id = shortid.generate();\n    this._session = null;\n    this._playerId = null;\n\n    this._socket.on('latency', this.handleLatency.bind(this));\n\n    logger.info(`client.connect (client_id: ${this._id})`);\n  }\n\n  /**\n   * Connects this client to a game session.\n   * @param {Session} session\n   */\n  joinSession(session) {\n    let playerProps = createProps({ type: 'player' });\n\n    session.addPlayer(playerProps);\n\n    this._channel = this._socket.join(session.channel);\n    this._channel.on('disconnect', this.handleDisconnect.bind(this));\n    this._channel.on('action', this.handleAction.bind(this));\n\n    setTimeout(() => {\n      playerProps = find(session.gameState.entities, props => props.id === playerProps.id);\n      this._channel.emit('ready', this._id, session.gameData, session.gameState, playerProps);\n\n      this._session = session;\n      this._playerId = playerProps.id;\n\n      logger.info(`client.join (client_id: ${this._id}, session_id: ${session.id})`);\n    }, CONNECT_DELAY);\n  }\n\n  /**\n   * Disconnects the client from the current game session.\n   */\n  leaveSession() {\n    if (!this._session) {\n      return;\n    }\n\n    this._channel.leave();\n\n    logger.info(`client.leave (client_id: ${this._id}, session_id: ${this._session.id})`);\n\n    this._session.removePlayer(this._playerId);\n    this._session = null;\n  }\n\n  /**\n   * Called each time the client pings the server.\n   * @param {number} timestamp\n   */\n  handleLatency(timestamp) {\n    this._socket.emit('latency', timestamp);\n  }\n\n  /**\n   * Called each time an action is received from the browser.\n   * @param {Object} action\n   */\n  handleAction(action) {\n    if (this._session) {\n      // TODO: Add a white-list for client actions and check against that.\n      // TODO: Consider adding a limit for how often actions will be dispatched.\n      this._session.handleClientAction(action);\n    }\n  }\n\n  /**\n   * Called when the connection to the browser is lost.\n   */\n  handleDisconnect() {\n    if (this._session) {\n      this.leaveSession();\n    }\n\n    this._server.removeClient(this._id);\n\n    logger.info(`client.disconnected (client_id: ${this._id})`);\n  }\n\n  /**\n   * Returns the id of this client.\n   * @returns {string}\n   */\n  get id() {\n    return this._id;\n  }\n}\n\nexport default Client;\n"]}